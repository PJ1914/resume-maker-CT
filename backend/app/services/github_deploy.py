"""
GitHub Pages deployment service
Handles repository creation and GitHub Pages setup
"""
import requests
import base64
import zipfile
import tempfile
import os
from typing import Dict, Any
import logging

logger = logging.getLogger(__name__)


class GitHubDeployService:
    """Service for deploying portfolios to GitHub Pages"""
    
    GITHUB_API_BASE = "https://api.github.com"
    
    def __init__(self):
        pass
    
    async def deploy(
        self,
        user_id: str,
        session_id: str,
        repo_name: str,
        zip_url: str,
        github_token: str,
        custom_domain: str = None
    ) -> Dict[str, Any]:
        """
        Deploy portfolio to GitHub Pages
        
        Args:
            user_id: Firebase user ID
            session_id: Portfolio session ID
            repo_name: Name for the GitHub repository
            zip_url: URL to the portfolio ZIP file
            github_token: GitHub Personal Access Token
        
        Returns:
            Dict with repo_url, url (pages url), and status
        """
        try:
            # Get GitHub username
            username = self._get_github_username(github_token)
            logger.info(f"üêô Deploying for GitHub user: {username}")
            
            # Create repository
            repo_full_name = self._create_repository(
                username=username,
                repo_name=repo_name,
                github_token=github_token
            )
            logger.info(f"‚úÖ Repository created: {repo_full_name}")
            
            # Download and extract ZIP
            files_content = self._download_and_extract_zip(zip_url)
            logger.info(f"üì¶ Extracted {len(files_content)} files from ZIP")
            
            # Upload files to repository
            self._upload_files_to_repo(
                repo_full_name=repo_full_name,
                files_content=files_content,
                github_token=github_token
            )
            logger.info(f"üì§ Uploaded {len(files_content)} files to repository")
            
            # Enable GitHub Pages
            pages_url = self._enable_github_pages(
                repo_full_name=repo_full_name,
                github_token=github_token
            )
            logger.info(f"üåê GitHub Pages enabled: {pages_url}")
            
            # Create CNAME file if custom domain provided
            dns_instructions = None
            if custom_domain:
                try:
                    self._create_cname_file(repo_full_name, custom_domain, github_token)
                    logger.info(f"‚úÖ CNAME file created for: {custom_domain}")
                    dns_instructions = self._get_dns_instructions(custom_domain, username, repo_name)
                except Exception as cname_error:
                    logger.warning(f"‚ö†Ô∏è Failed to create CNAME: {cname_error}")
            
            result = {
                "repo_url": f"https://github.com/{repo_full_name}",
                "url": pages_url,
                "status": "deployed",
                "message": f"Portfolio deployed successfully! GitHub Pages may take 1-2 minutes to become available."
            }
            
            if dns_instructions:
                result["custom_domain"] = custom_domain
                result["dns_instructions"] = dns_instructions
                result["message"] += f" CNAME file created for {custom_domain}. Please configure DNS settings."
            
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Deployment failed: {str(e)}")
            raise Exception(f"Deployment failed: {str(e)}")
    
    def _get_github_username(self, github_token: str) -> str:
        """Get GitHub username from token"""
        headers = {
            "Authorization": f"token {github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        response = requests.get(f"{self.GITHUB_API_BASE}/user", headers=headers)
        
        if response.status_code != 200:
            raise Exception(f"Failed to get GitHub user: {response.json().get('message', 'Unknown error')}")
        
        return response.json()["login"]
    
    def _create_repository(
        self,
        username: str,
        repo_name: str,
        github_token: str
    ) -> str:
        """Create a new GitHub repository"""
        headers = {
            "Authorization": f"token {github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        data = {
            "name": repo_name,
            "description": f"Portfolio website generated by Prativeda CT",
            "homepage": f"https://{username}.github.io/{repo_name}",
            "private": False,
            "has_issues": False,
            "has_projects": False,
            "has_wiki": False,
            "auto_init": True  # Initialize with README
        }
        
        response = requests.post(
            f"{self.GITHUB_API_BASE}/user/repos",
            headers=headers,
            json=data
        )
        
        if response.status_code == 422:
            # Repository already exists, try to use it
            logger.warning(f"Repository {repo_name} already exists, will update it")
            return f"{username}/{repo_name}"
        elif response.status_code != 201:
            error_msg = response.json().get('message', 'Unknown error')
            raise Exception(f"Failed to create repository: {error_msg}")
        
        return response.json()["full_name"]
    
    def _download_and_extract_zip(self, zip_url: str) -> Dict[str, bytes]:
        """Download ZIP and extract all files"""
        # Download ZIP
        response = requests.get(zip_url)
        if response.status_code != 200:
            raise Exception(f"Failed to download ZIP: {response.status_code}")
        
        # Save to temp file and extract
        files_content = {}
        
        with tempfile.NamedTemporaryFile(delete=False, suffix='.zip') as temp_zip:
            temp_zip.write(response.content)
            temp_zip_path = temp_zip.name
        
        try:
            with zipfile.ZipFile(temp_zip_path, 'r') as zip_ref:
                for file_info in zip_ref.filelist:
                    if not file_info.is_dir():
                        file_path = file_info.filename
                        # Skip __MACOSX and other system files
                        if '__MACOSX' in file_path or file_path.startswith('.'):
                            continue
                        
                        content = zip_ref.read(file_info.filename)
                        files_content[file_path] = content
        finally:
            os.unlink(temp_zip_path)
        
        return files_content
    
    def _upload_files_to_repo(
        self,
        repo_full_name: str,
        files_content: Dict[str, bytes],
        github_token: str
    ):
        """Upload all files to GitHub repository"""
        headers = {
            "Authorization": f"token {github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        for file_path, content in files_content.items():
            # Encode content to base64
            content_base64 = base64.b64encode(content).decode('utf-8')
            
            # Check if file exists (to get SHA for update)
            sha = None
            get_response = requests.get(
                f"{self.GITHUB_API_BASE}/repos/{repo_full_name}/contents/{file_path}",
                headers=headers
            )
            if get_response.status_code == 200:
                sha = get_response.json().get('sha')
            
            # Create or update file
            data = {
                "message": f"Add {file_path}" if not sha else f"Update {file_path}",
                "content": content_base64
            }
            if sha:
                data["sha"] = sha
            
            response = requests.put(
                f"{self.GITHUB_API_BASE}/repos/{repo_full_name}/contents/{file_path}",
                headers=headers,
                json=data
            )
            
            if response.status_code not in [200, 201]:
                logger.warning(f"Failed to upload {file_path}: {response.json().get('message', 'Unknown error')}")
    
    def _enable_github_pages(
        self,
        repo_full_name: str,
        github_token: str
    ) -> str:
        """Enable GitHub Pages for the repository"""
        headers = {
            "Authorization": f"token {github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        data = {
            "source": {
                "branch": "main",
                "path": "/"
            }
        }
        
        # Try to create Pages site
        response = requests.post(
            f"{self.GITHUB_API_BASE}/repos/{repo_full_name}/pages",
            headers=headers,
            json=data
        )
        
        # If already exists, get the URL
        if response.status_code == 409:
            get_response = requests.get(
                f"{self.GITHUB_API_BASE}/repos/{repo_full_name}/pages",
                headers=headers
            )
            if get_response.status_code == 200:
                return get_response.json().get('html_url')
        
        if response.status_code in [200, 201]:
            return response.json().get('html_url')
        
        # Fallback to constructed URL
        username = repo_full_name.split('/')[0]
        repo_name = repo_full_name.split('/')[1]
        return f"https://{username}.github.io/{repo_name}/"
    
    def _create_cname_file(self, repo_full_name: str, custom_domain: str, github_token: str):
        """Create CNAME file in repository for custom domain"""
        headers = {
            "Authorization": f"token {github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        # Encode CNAME content
        content = base64.b64encode(custom_domain.encode()).decode()
        
        data = {
            "message": "Add CNAME for custom domain",
            "content": content
        }
        
        response = requests.put(
            f"{self.GITHUB_API_BASE}/repos/{repo_full_name}/contents/CNAME",
            headers=headers,
            json=data
        )
        
        if response.status_code not in [200, 201]:
            raise Exception(f"Failed to create CNAME: {response.json().get('message', 'Unknown error')}")
    
    def _get_dns_instructions(self, custom_domain: str, username: str, repo_name: str) -> Dict[str, Any]:
        """Generate DNS configuration instructions"""
        is_apex_domain = custom_domain.count('.') == 1
        
        if is_apex_domain:
            # Apex domain (example.com)
            return {
                "type": "A",
                "records": [
                    {"type": "A", "host": "@", "value": "185.199.108.153"},
                    {"type": "A", "host": "@", "value": "185.199.109.153"},
                    {"type": "A", "host": "@", "value": "185.199.110.153"},
                    {"type": "A", "host": "@", "value": "185.199.111.153"}
                ],
                "instructions": f"Add these A records to your DNS provider for {custom_domain}"
            }
        else:
            # Subdomain (www.example.com or portfolio.example.com)
            subdomain = custom_domain.split('.')[0]
            return {
                "type": "CNAME",
                "records": [
                    {"type": "CNAME", "host": subdomain, "value": f"{username}.github.io"}
                ],
                "instructions": f"Add this CNAME record to your DNS provider for {custom_domain}"
            }

    def delete_repository(self, repo_name: str, github_token: str) -> bool:
        """
        Delete a GitHub repository
        
        Args:
            repo_name: Repository name (owner/repo or just repo)
            github_token: GitHub Personal Access Token
        """
        try:
            # Get username ensuring we have owner/repo format
            if '/' not in repo_name:
                username = self._get_github_username(github_token)
                full_repo_name = f"{username}/{repo_name}"
            else:
                full_repo_name = repo_name
                
            headers = {
                "Authorization": f"token {github_token}",
                "Accept": "application/vnd.github.v3+json"
            }
            
            logger.info(f"üóëÔ∏è Deleting GitHub repository: {full_repo_name}")
            
            response = requests.delete(
                f"{self.GITHUB_API_BASE}/repos/{full_repo_name}",
                headers=headers
            )
            
            if response.status_code == 204:
                logger.info(f"‚úÖ Repository deleted: {full_repo_name}")
                return True
            elif response.status_code == 404:
                logger.warning(f"Repository {full_repo_name} not found, already deleted?")
                return True
            else:
                error_msg = response.json().get('message', 'Unknown error')
                raise Exception(f"GitHub API Error ({response.status_code}): {error_msg}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to delete GitHub repository: {str(e)}")
            raise
